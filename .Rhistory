rownames(dat3) <- unlist(select(data2,geneID))
#view(dat3)
color <- c("red","green","orange","pink","purple")
if(!require(RColorBrewer))install.packages("RColorBrewer")
library(RColorBrewer)
color1 <- brewer.pal(4,"Set1")
color2 <- brewer.pal(4,"Set2")
color3 <- brewer.pal(4,"Dark2")
color4 <- brewer.pal(4,"Accent")
if(length(dat3)>4){
dat3 <- select(dat3,1:4)
warning("the input dataframe columns are more than 4! Only show the first 4 columns")
}
img <- ggvenn(dat3,set_name_size = 4,text_size = 4,fill_color = fill_color,fill_alpha=0.6,show_percentage = TRUE)
return(img)
}
get_venn(data2 %>% select(2:4))
get_venn <- function(data2,geneID="geneID",fill_color = color){
# #检测输入的geneID是否是正确的列名，如果不是，则报错。
# if (! geneID %in% colnames(data2)){
#   message("The input ",geneID," not a column name for the input dataframe!")
#   }
#设置删除geneID的列，同时转为逻辑矩阵
dat3 <- data.frame(Map(as.logical,select(data2,-(geneID))))
#select返回的值是list,rowname需要的是向量.所以用unlist
rownames(dat3) <- unlist(select(data2,geneID))
#view(dat3)
color <- c("red","green","orange","pink","purple")
if(!require(RColorBrewer))install.packages("RColorBrewer")
library(RColorBrewer)
color1 <- brewer.pal(4,"Set1")
color2 <- brewer.pal(4,"Set2")
color3 <- brewer.pal(4,"Dark2")
color4 <- brewer.pal(4,"Accent")
if(length(dat3)>4){
dat3 <- select(dat3,1:4)
warning("the input dataframe columns are more than 4! Only show the first 4 columns")
}
img <- ggvenn(dat3,set_name_size = 4,text_size = 4,fill_color = fill_color,fill_alpha=0.6,show_percentage = TRUE)
return(img)
}
get_venn(data2 %>% select(2:4))
get_venn <- function(data2,geneID="geneID",fill_color = color){
# #检测输入的geneID是否是正确的列名，如果不是，则报错。
if (! geneID %in% colnames(data2)){
message("The input ",geneID," not a column name for the input dataframe!")
break
}
#设置删除geneID的列，同时转为逻辑矩阵
dat3 <- data.frame(Map(as.logical,select(data2,-(geneID))))
#select返回的值是list,rowname需要的是向量.所以用unlist
rownames(dat3) <- unlist(select(data2,geneID))
#view(dat3)
color <- c("red","green","orange","pink","purple")
if(!require(RColorBrewer))install.packages("RColorBrewer")
library(RColorBrewer)
color1 <- brewer.pal(4,"Set1")
color2 <- brewer.pal(4,"Set2")
color3 <- brewer.pal(4,"Dark2")
color4 <- brewer.pal(4,"Accent")
if(length(dat3)>4){
dat3 <- select(dat3,1:4)
warning("the input dataframe columns are more than 4! Only show the first 4 columns")
}
img <- ggvenn(dat3,set_name_size = 4,text_size = 4,fill_color = fill_color,fill_alpha=0.6,show_percentage = TRUE)
return(img)
}
get_venn(data2 %>% select(2:4))
for(i in 1:10) {                        # For-loop containing error condition
if(i != 5) {
print(paste("Finished loop iteration No.", i))
}
if(i == 5) {
stop("i was equal to 5!")
}
}
get_venn <- function(data2,geneID="geneID",fill_color = color){
# #检测输入的geneID是否是正确的列名，如果不是，则报错。
if (! geneID %in% colnames(data2)){
stop("The input ",geneID," not a column name for the input dataframe!")
#break
}
#设置删除geneID的列，同时转为逻辑矩阵
dat3 <- data.frame(Map(as.logical,select(data2,-(geneID))))
#select返回的值是list,rowname需要的是向量.所以用unlist
rownames(dat3) <- unlist(select(data2,geneID))
#view(dat3)
color <- c("red","green","orange","pink","purple")
if(!require(RColorBrewer))install.packages("RColorBrewer")
library(RColorBrewer)
color1 <- brewer.pal(4,"Set1")
color2 <- brewer.pal(4,"Set2")
color3 <- brewer.pal(4,"Dark2")
color4 <- brewer.pal(4,"Accent")
if(length(dat3)>4){
dat3 <- select(dat3,1:4)
warning("the input dataframe columns are more than 4! Only show the first 4 columns")
}
img <- ggvenn(dat3,set_name_size = 4,text_size = 4,fill_color = fill_color,fill_alpha=0.6,show_percentage = TRUE)
return(img)
}
get_venn(data2 %>% select(2:4))
get_venn <- function(data2,geneID="geneID",fill_color = color){
# #检测输入的geneID是否是正确的列名，如果不是，则报错。
if (! geneID %in% colnames(data2)){
stop("The input geneID not a column name for the input dataframe!")
#break
}
#设置删除geneID的列，同时转为逻辑矩阵
dat3 <- data.frame(Map(as.logical,select(data2,-(geneID))))
#select返回的值是list,rowname需要的是向量.所以用unlist
rownames(dat3) <- unlist(select(data2,geneID))
#view(dat3)
color <- c("red","green","orange","pink","purple")
if(!require(RColorBrewer))install.packages("RColorBrewer")
library(RColorBrewer)
color1 <- brewer.pal(4,"Set1")
color2 <- brewer.pal(4,"Set2")
color3 <- brewer.pal(4,"Dark2")
color4 <- brewer.pal(4,"Accent")
if(length(dat3)>4){
dat3 <- select(dat3,1:4)
warning("the input dataframe columns are more than 4! Only show the first 4 columns")
}
img <- ggvenn(dat3,set_name_size = 4,text_size = 4,fill_color = fill_color,fill_alpha=0.6,show_percentage = TRUE)
return(img)
}
get_venn(data2 %>% select(2:4))
get_venn <- function(data2,geneID="geneID",fill_color = color){
# #检测输入的geneID是否是正确的列名，如果不是，则报错。
if (! geneID %in% colnames(data2)){
message("The input ",geneID," not a column name for the input dataframe!")
break
}
#设置删除geneID的列，同时转为逻辑矩阵
dat3 <- data.frame(Map(as.logical,select(data2,-(geneID))))
#select返回的值是list,rowname需要的是向量.所以用unlist
rownames(dat3) <- unlist(select(data2,geneID))
#view(dat3)
color <- c("red","green","orange","pink","purple")
if(!require(RColorBrewer))install.packages("RColorBrewer")
library(RColorBrewer)
color1 <- brewer.pal(4,"Set1")
color2 <- brewer.pal(4,"Set2")
color3 <- brewer.pal(4,"Dark2")
color4 <- brewer.pal(4,"Accent")
if(length(dat3)>4){
dat3 <- select(dat3,1:4)
warning("the input dataframe columns are more than 4! Only show the first 4 columns")
}
img <- ggvenn(dat3,set_name_size = 4,text_size = 4,fill_color = fill_color,fill_alpha=0.6,show_percentage = TRUE)
return(img)
}
get_venn(data2 %>% select(2:4))
get_venn(data2 %>% select(1:4))
get_venn(data2 %>% select(1:2))
get_venn(data2 %>% select(1:3))
get_venn(data2)
par(mfrow=c(1,2))
get_venn(data2)
get_venn(data2)
data2
gene2venn <- function(data_gene,outname){
data_gene <- data_venn
data2 <- get_matrix(data_gene)
write.csv(data2,file=paste0(outname,"_matrix.csv"))
pdf(paste0(outname,"_upset.pdf"))
get_upset(data2)
dev.off()
p2 <- get_venn(data2)
ggsave(filename=paste0(outname,"_venn.pdf"),p1)
}
gene2venn(data_venn)
gene2venn <- function(data_gene,outname="demo"){
data_gene <- data_venn
data2 <- get_matrix(data_gene)
write.csv(data2,file=paste0(outname,"_matrix.csv"))
pdf(paste0(outname,"_upset.pdf"))
get_upset(data2)
dev.off()
p2 <- get_venn(data2)
ggsave(filename=paste0(outname,"_venn.pdf"),p1)
}
gene2venn(data_venn)
data_gene <- data_venn
outname="demo"
data2 <- get_matrix(data_gene)
write.csv(data2,file=paste0(outname,"_matrix.csv"))
pdf(paste0(outname,"_upset.pdf"))
get_upset(data2)
dev.off()
p2 <- get_venn(data2)
ggsave(filename=paste0(outname,"_venn.pdf"),p1)
paste0(outname,"_venn.pdf")
get_venn(data2)
get_venn(data2%>%select(1:4))
p2 <- get_venn(data2%>%select(1:4))
ggsave(filename=paste0(outname,"_venn.pdf"),p1)
pdf(paste0(outname,"_venn.pdf"))
get_venn(data2%>%select(1:4))
dev.off()
gene2venn <- function(data_gene,outname="demo"){
#data_gene <- data_venn
#outname="demo"
data2 <- get_matrix(data_gene)
write.csv(data2,file=paste0(outname,"_matrix.csv"))
pdf(paste0(outname,"_upset.pdf"))
get_upset(data2)
dev.off()
pdf(paste0(outname,"_venn.pdf"))
get_venn(data2)
dev.off()
return(data2)
}
gene_matrix <- gene2venn(data_venn)
getwd()
csvfile <- paste0(outname,"_matrix.csv")
wdpath <- getwd()
wdpath + csvfile
paste(wdpath,csvfile,sep = "/")
message("output gene matrix in :",paste(wdpath,csvfile,sep = "/"))
print("output gene matrix in :",paste(wdpath,csvfile,sep = "/"))
print("this is a test file")
warning("The less than 0.05 value will be delete!")
stop("Need 3 parameter!")
message("Outfile is ","new.csv")
upsetfile
gene2venn <- function(data_gene,outname="demo"){
#data_gene <- data_venn
#outname="demo"
data2 <- get_matrix(data_gene)
csvfile <- paste0(outname,"_matrix.csv")
write.csv(data2,file=csvfile)
wdpath <- getwd()
message("output gene matrix in :",paste(wdpath,csvfile,sep = "/"))
upsetfile <- paste0(outname,"_upset.pdf")
pdf(upsetfile)
get_upset(data2)
dev.off()
message("output upset image in :",paste(wdpath,upsetfile,sep = "/"))
vennfile <- paste0(outname,"_venn.pdf")
pdf(vennfile)
get_venn(data2)
dev.off()
message("output venn image in :",paste(wdpath,vennfile,sep = "/"))
return(data2)
}
gene_matrix <- gene2venn(data_venn)
Reduce(union,gene_matrix)
Reduce(intersect,gene_matrix)
head(gene_matrix)
Reduce(intersect,gene_matrix%>%select(1:4))
Reduce(intersect,gene_matrix%>%select(1:4,-(geneID)))
Reduce(intersect,data_venn)
get_upset <- function(data_venn_logic,nsets=10){
#筛选过滤不包含指定的列
#(data_venn_logic %>% select(-(Z58_Chang7_2),-(PH4CVvsPH6WC)))
#使用UpSetR进行Veen可视化
img <- upset(data_venn_logic, nsets = nsets, #nSets设置需要veen的列数
nintersects = NA, #显示的最小的交集的基因的数目 NA表示显示所有的，10，则表示交集>=10的
mb.ratio = c(0.5, 0.5),
order.by = c("freq", "degree"),
decreasing = c(TRUE,FALSE))
return(img)
}
gene2venn <- function(data_gene,outname="demo"){
#data_gene <- data_venn
#outname="demo"
data2 <- get_matrix(data_gene)
csvfile <- paste0(outname,"_matrix.csv")
write.csv(data2,file=csvfile)
wdpath <- getwd()
message("output gene matrix in :",paste(wdpath,csvfile,sep = "/"))
upsetfile <- paste0(outname,"_upset.pdf")
pdf(upsetfile)
get_upset(data2)
dev.off()
message("output upset image in :",paste(wdpath,upsetfile,sep = "/"))
vennfile <- paste0(outname,"_venn.pdf")
pdf(vennfile)
get_venn(data2)
dev.off()
message("output venn image in :",paste(wdpath,vennfile,sep = "/"))
return(data2)
}
gene_matrix <- gene2venn(data_venn)
library(tidyverse)
##数据包 航班 世界发展 棒球数据
if(!require(c("nycflights13", "gapminder", "Lahman")))install.packages(c("nycflights13", "gapminder", "Lahman")) #三个数据包
library(nycflights13)
flights #是2013年美国纽约出发的航班信息
#dplyr常用的函数
#根据其值（filter()）选择观察值。
#重新排序行（arrange()）。
#按变量名称（select()）选择变量。
#使用现有变量（mutate()）的功能创建新变量。
#将许多值折叠为一个摘要（summarise()）。
April_1st <- filter(flights,month==4,day==1) #查询2013年4月1日出发的航班
filter(flights,!(dep_delay>60|arr_delay>60),month %in% c(4,5,6)) #查看第二季度的出发和到达时间延误均小于等于60min的航班
#查找早上7点前到达和23点之后到达的航班，根据出发时间从早到晚，和到达时间从晚到早排序
filter(flights,arr_time<700 | arr_time>2300) %>% arrange(dep_time,desc(arr_time))
flights %>% arrange(origin) %>% group_by(origin) %>%
select(contains("time"),dest,distance) %>%
mutate(groundtime = arr_time - dep_time - air_time) %>%
arrange(desc(groundtime))
flights %>% head(10)
flights %>% head(10) %>% identity()
flights %>% head(10) %>% NULL
flights %>% head(10) %>% ggplot(aes(x=flight))+geom_hline()
flights %>% head(10) %>% ggplot(aes(x=origin,y=flight))+geom_hline()
flights %>% head(10) %>% ggplot(aes(x=origin,y=flight))+geom_histogram()
flights %>% head(10) %>% ggplot(aes(y=flight))+geom_histogram()
flights %>% head(10) %>% ggplot(aes(x=flight))+geom_histogram()
flights %>% head(10) %>% ggplot(aes(x=air_time))+geom_histogram()
flights %>% head(10) %>% ggplot(aes(x=air_time))+geom_histogram()+
geom_boxplot(aes(x=carrier,y=flight))
p <- ggplot(mpg, aes(class, hwy))
p + geom_boxplot()
head(mpg)
flights %>% head(10) %>% ggplot(aes(x=air_time))+geom_histogram()+
geom_boxplot(aes(carrier,flight))
flights %>% head(10) %>% ggplot(aes(x=air_time))+
#geom_histogram()+
NULL+
geom_boxplot(aes(carrier,flight))
flights %>% head(10) %>% ggplot(aes(x=air_time))+
#geom_histogram()+
NULL
p+barplot()
p+geom_bar()
p+geom_bar(aes(x=hwy))
p+geom_bar(aes(y=hwy))
p+geom_ribbon()
p+geom_boxplot()
p+geom_boxplot()+theme_classic()
flights %>% head(10) %>%
identify()
flights %>% head(10) %>%
identify()
flights %>% head(10) %>%
identity()
flights %>% head(10) %>%
identity() %>% rownames()
mpg %>% head(10) %>%
identity() %>% rownames()
mpg %>% head(10) %>%
identity()
box::use(plog = ggplot2)
pak::pkg_install(export)
pak::pkg_install(box)
pak::pkg_install('box')
pak::pkg_install('ggplot2')
pak::pkg_install("box",upgrade = TRUE)
pak::pkg_install("r-lib/box",upgrade = TRUE)
pak::pkg_install("r-lib/ggplot2",upgrade = TRUE)
pak::pkg_install('r-lib/ggplot2',upgrade = TRUE)
pak::pkg_install('r-lib/rlang',upgrade = TRUE)
pak::pkg_install('r-lib/rlang',upgrade = TRUE)
pak::pkg_install(pkg = "tidyverse", ask = F, lib = .libPaths()[[1]])
pak::pkg_install("usethis")
utils::install.packages('pak', repos = 'https://r-lib.github.io/p/pak/dev/')
pak::pkg_install("usethis")
install.packages("ggbreak")
library(ggbreak)
if(!require(ggplot2))install.packages("ggplot2")
if(!require(tidyverse))install.packages("tidyverse")
if(!require(ggprism))remotes::install_github("csdaw/ggprism")
library(ggplot2)
library(tidyverse)
library(ggprism) #可以完善ggplot2的图使之达到发表级别
dat1 <- read.csv("../data/enrich_result.csv")
barplot(dat1,term_num = 3)
getwd()
dat1 <- read.csv("./data/enrich_result.csv")
barplot(dat1,term_num = 3)
barplot <- function(data_GO_all,fill_level=c("MF","BP","CC","KEGG"),term_num=8,term_width=40){
data1 <- data_GO_all %>% arrange(type,desc(count)) %>% group_by(type) %>%
slice(1:term_num) #筛选出前n项用于展示
#分组排序
data_GO_all <- group_by(data1,type) %>%
arrange(desc(type),count)
#根据分组排序的结果进行factor。用于固定顺序，绘图时按照这个顺序绘图
data_GO_all$type <- factor(data_GO_all$type,levels = fill_level)
data_GO_all$Description <- factor(data_GO_all$Description,levels = data_GO_all$Description)
p1 <- ggplot(data_GO_all) +
geom_bar(stat="identity",aes(x=count,y=Description,fill=type))+
#facet_wrap(~group)+ #设置分面
labs(y='Term',x='Count',fill='Type')+ #设置标题
#coord_flip() + 颠倒xy轴
scale_y_discrete(labels=function(x) str_wrap(x, width=term_width))+ #设置term的description的宽度，自动换行
theme_prism(base_size=10) #使用prism标准化图，达到出版级别
p1
return(p1)
}
barplot(dat1,term_num = 3)
barplot(dat1,term_num = 4)
library(ggbreak)
?ggbreak
??ggbreak
barplot(dat1,term_num = 4)+scale_x_break(30,50)
barplot(dat1,term_num = 4)+scale_x_break(c(30,50))
barplot(dat1,term_num = 4)+scale_x_break(c(30,50))
barplot <- function(data_GO_all,fill_level=c("MF","BP","CC","KEGG"),term_num=8,term_width=40){
data1 <- data_GO_all %>% arrange(type,desc(count)) %>% group_by(type) %>%
slice(1:term_num) #筛选出前n项用于展示
#分组排序
data_GO_all <- group_by(data1,type) %>%
arrange(desc(type),count)
#根据分组排序的结果进行factor。用于固定顺序，绘图时按照这个顺序绘图
data_GO_all$type <- factor(data_GO_all$type,levels = fill_level)
data_GO_all$Description <- factor(data_GO_all$Description,levels = data_GO_all$Description)
p1 <- ggplot(data_GO_all) +
geom_bar(stat="identity",aes(x=count,y=Description,fill=type))+
#facet_wrap(~group)+ #设置分面
labs(y='Term',x='Count',fill='Type')+ #设置标题
#coord_flip() + 颠倒xy轴
scale_y_discrete(labels=function(x) str_wrap(x, width=term_width))+ #设置term的description的宽度，自动换行
NULL
#theme_prism(base_size=10) #使用prism标准化图，达到出版级别
p1
return(p1)
}
barplot(dat1,term_num = 4)+scale_x_break(c(30,50))
require(ggplot2 )
set.seed(2019-01-19)
d <- data.frame(
x = 1:20,
y = c(rnorm(5) + 4, rnorm(5) + 20, rnorm(5) + 5, rnorm(5) + 22)
)
p <- ggplot(d, aes(x, y)) + geom_col()
x <- p+scale_y_break(c(7, 17 ) )
print(x)
p
p+scale_y_break(c(7,18))
p+scale_y_break(c(7,18))+theme_classic()
barplot(dat1,term_num = 4)+scale_x_break(c(30,50))
p+scale_y_break(c(7,18))+theme_classic()
remotes::install_github("GuangchuangYu/ggbreak")
remotes::install_github("GuangchuangYu/ggbreak")
devtools::install("GuangchuangYu/ggbreak")
ggplot(economics, aes(x = ggtree::Date2decimal(date), y = unemploy, colour = uempmed)) +
geom_line() -> p
scale_wrap <- function(n) {
}
p + scale_wrap(4)
install.packages("ggtree")
BiocManager::install("ggtree")
BiocManager::install("ggtree")
BiocManager::install("ggtree")
barplot(dat1,term_num = 4)+scale_x_break(c(30,50))+geom_tiplab()
barplot(dat1,term_num = 4)+scale_x_break(c(30,50))
pak::pkg_install("dplyr")
pak::pkg_install("ggtree")
pak::pkg_install("ggsci")
pak::pkg_install("ggplot2")
pak::pkg_install("ggtree")
pak::pkg_install("clusterProfilter")
pak::pkg_install("clusterProfiler")
pak::pkg_install("ggrepel")
pak::pkg_install("RColorBrewer")
pak::pkg_install("tomwenseleers/export")
barplot(dat1,term_num = 5,term_width = 45)
dat1 <- read.csv("./data/enrich_result.csv")
barplot(dat1,term_num = 4)
barplot <- function(data_GO_all,fill_level=c("MF","BP","CC","KEGG"),term_num=8,term_width=40){
data1 <- data_GO_all %>% arrange(type,desc(count)) %>% group_by(type) %>%
slice(1:term_num) #筛选出前n项用于展示
#分组排序
data_GO_all <- group_by(data1,type) %>%
arrange(desc(type),count)
#根据分组排序的结果进行factor。用于固定顺序，绘图时按照这个顺序绘图
data_GO_all$type <- factor(data_GO_all$type,levels = fill_level)
data_GO_all$Description <- factor(data_GO_all$Description,levels = data_GO_all$Description)
p1 <- ggplot(data_GO_all) +
geom_bar(stat="identity",aes(x=count,y=Description,fill=type))+
#facet_wrap(~group)+ #设置分面
labs(y='Term',x='Count',fill='Type')+ #设置标题
#coord_flip() + 颠倒xy轴
scale_y_discrete(labels=function(x) str_wrap(x, width=term_width))+ #设置term的description的宽度，自动换行
NULL
#theme_prism(base_size=10) #使用prism标准化图，达到出版级别
p1
return(p1)
}
barplot(dat1,term_num = 4)
library(ggplot2)
library(tidyverse)
library(ggprism) #可以完善ggplot2的图使之达到发表级别
barplot <- function(data_GO_all,fill_level=c("MF","BP","CC","KEGG"),term_num=8,term_width=40){
data1 <- data_GO_all %>% arrange(type,desc(count)) %>% group_by(type) %>%
slice(1:term_num) #筛选出前n项用于展示
#分组排序
data_GO_all <- group_by(data1,type) %>%
arrange(desc(type),count)
#根据分组排序的结果进行factor。用于固定顺序，绘图时按照这个顺序绘图
data_GO_all$type <- factor(data_GO_all$type,levels = fill_level)
data_GO_all$Description <- factor(data_GO_all$Description,levels = data_GO_all$Description)
p1 <- ggplot(data_GO_all) +
geom_bar(stat="identity",aes(x=count,y=Description,fill=type))+
#facet_wrap(~group)+ #设置分面
labs(y='Term',x='Count',fill='Type')+ #设置标题
#coord_flip() + 颠倒xy轴
scale_y_discrete(labels=function(x) str_wrap(x, width=term_width))+ #设置term的description的宽度，自动换行
theme_prism(base_size=10) #使用prism标准化图，达到出版级别
p1
return(p1)
}
barplot(dat1,term_num = 4)
p1 <- barplot(dat1,term_num = 4)
graph2ppt(p1,file="barplot.ppt")
library(export)
graph2ppt(p1,file="barplot.ppt")
